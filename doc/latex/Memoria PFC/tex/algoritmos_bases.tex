\documentclass[../main.tex]{subfiles}
% Preamble
\begin{document}
	
\chapter{ALGORITMOS DE CÁLCULO DE BASES}\label{chap:algoritmosBases}
	\newpage
	En esta sección se incluyen los pseudocódigos de los algoritmos implementados para el cálculo de bases directas, por el grupo de investigación GIMAC, en colaboración
	con la Dra. K. Bertet de la Universidad de La Rochelle. Uno de los objetivos de este proyecto es implementar estos algoritmos en Java siguiendo las estructuras de datos
	que están implementadas en el repositorio \url{https://github.com/kbertet/java-lattices} ya que es probable que en un futuro dichos
	algoritmos se incluyan en esta librería.
	
	La estructura principal usada es la clase \textit{ImplicationalSystem} que representa un conjunto o sistema de implicaciones e implementa las operaciones
	clásicas sobre éstos: sitema propio, base canónica, base canónica directa, sistema unario, etc. 
	
	\textit{ImplicationalSystem} está compuesto por un conjunto de elementos (atributo \texttt{set} en la Figura \ref{fig:java-lattice}) y un conjunto de implicaciones
	representadas mediante la clase \textit{Rule}.
	Ésta a su vez está compuesta por dos conjuntos de atributos que representan la premisa y la	conclusión de la implicación e implementa métodos para la
	obtención de cada una de las partes así como para la adición y eliminación de elementos de éstas. En la Figura \ref{fig:java-lattice} se muestra el diagrama de clases
	con los métodos y relaciones más relevantes:
	
	\begin{figure}[H]
		\centering
			\includegraphics[width=1.00\textwidth]{diagramas/java-lattice.png}
		\caption{Clases librería java-lattice}
		\label{fig:java-lattice}
	\end{figure}
		
	
	Un ejemplo del uso de estos tipos, se puede ver en el cálculo de la cardinalidad de un sistema implicacional:

	\begin{figure}[H]
		\centering
			\includegraphics[scale=0.9]{imagenes/figura56.png}
		\caption{Cálculo de la cardinalidad de un sistema implicacional}
		\label{fig:cardinality}
	\end{figure}
	
	O en el cálculo de su tamaño:
	
	\begin{figure}[H]
		\centering
			\includegraphics[scale=0.9]{imagenes/figura57.png}
		\caption{Cálculo del tamaño de un sistema implicacional}
		\label{fig:size}
	\end{figure}
	
	\pagebreak
	\section{CLA}
		A continuación se muestra el algoritmo CLA presentado en el artículo \cite{bib:ref9}, definiéndose primeramente las
		funciones \textit{Direct-Reduced} y \textit{RD-Simplify} que después son usadas en el algoritmo. Para abreviar, se 
		hará referencia al sistema implicacional con las siglas en inglés IS (Implicational System).
				
		La función \textit{Direct-Reduced($\Sigma$)} calcula el IS directo-reducido de $\Sigma$:
		\newline
		
		\begin{tabular}[c]{p{15cm}}
			\hline
			Direct-Reduced($\Sigma$)\\
			\hline
			
			\textbf{input}: Un sistema implicacional $\Sigma$	en S	\\
			\textbf{output}: El IS directo-reducido $\Sigma_{dr}$ en S	\\
			\textbf{begin}												\\
			\ESPACIO \FOREACH $A \rightarrow B \in \Sigma_{dr}$ y $C \rightarrow D \in \Sigma_{dr}$ \DO\\
			\ESPACIO \ESPACIO \IF $B \cap c \neq \emptyset \neq D \backslash (A \cup B)$ \THEN add $AC-B \rightarrow D-(AB)$ to
							 $\Sigma_{dr}$; \\
			\ESPACIO \RETURN $\Sigma_{dr}$ \\
			\hline
		\end{tabular}
		\newline
		
		
		La función \textit{RD-Simplify($\Sigma$)} calcula el IS directo-reducido-simplificado a partir de $\Sigma$ reducido:
		\newline
		
		\begin{tabular}[c]{p{15cm}}
			\hline
			RD-Simplify($\Sigma$)\\
			\hline
			
			\textbf{input}: Un sistema implicacional directo-reducido $\Sigma$	en S	\\
			\textbf{output}: El IS directo-reducido-simplificado $\Sigma_{drs}$ en S equivalente a $\Sigma$	\\
			\textbf{begin}												\\
			\ESPACIO $\Sigma_{drs} := \emptyset$ \\
			\ESPACIO \FOREACH $A \rightarrow B \in \Sigma$ \DO \\
			\ESPACIO \ESPACIO \FOREACH $C \rightarrow D \in \Sigma$ \DO \\
			\ESPACIO \ESPACIO \ESPACIO \IF $C = A$ \THEN $B := B \cup D$; \\
			\ESPACIO \ESPACIO \ESPACIO \IF $C \nsubseteq A$ \THEN $B := B \backslash D$; \\
			\ESPACIO \ESPACIO \IF $B \neq \emptyset$ \THEN add $A \rightarrow B$ to $\Sigma{drs}$; \\
			\ESPACIO \RETURN $\Sigma_{drs}$ \\
			\hline
		\end{tabular}
		\newline
		\newline
		
		La función \textit{doSimp($\Sigma$)} calcula el IS directo-óptimo equivalente a $\Sigma$ usando las dos funciones
		 anteriores:
		\newline
		\newline
			\begin{tabular}[c]{p{15cm}}
				\hline
					doSimp($\Sigma$)\\
				\hline
				%
				\textbf{input}: Un sistema implicacional $\Sigma$	en S	\\
				\textbf{output}: El IS directo-óptimo $\Sigma_{do}$	en S	\\
				\textbf{begin}												\\
				\ESPACIO $\Sigma_r := \left\{A \rightarrow B-A | A \rightarrow B \in \Sigma, B \nsubseteq A
				 					 \right\}$\\			
				\ESPACIO $\Sigma_{dr}$ := Direct-Reduced($\Sigma_r$)\\
				\ESPACIO $\Sigma_{do}$ := RD-Simplify($\Sigma_{dr}$)\\
				\RETURN $\Sigma_{do}$\\
				\hline
			\end{tabular}
		
	\pagebreak
	\section{Direct Optimal Basis}
		A continuación se muestra el algortimo Direct Optimal Basis presentado en el artículo \cite{bib:ref1}. La diferencia con el algoritmo CLA, es que se hace
		una simplificación izquierda y derecha antes de aplicar la regla Strong Simplification.
		
		\begin{tabular}{l p{15cm}}
							& \textbf{input}: Un sistema implicacional $\Sigma$	en S	\\
							& \textbf{output}: El IS directo-óptimo $\Sigma_{do}$	en S	\\
			 1				& \textbf{begin}												\\
			 2				& /* Fase 1: Generación de $\Sigma_r$ por reducción de $\Sigma$*/ \\
			 3				& $\Sigma_r = \emptyset$ \\
			 4				& \FOREACH $A \rightarrow_{\Sigma} B$ \DO\\
			 5				& \ESPACIO \IF $B \nsubseteq A$ \THEN add $A \rightarrow B-A$ to $\Sigma_r $; \\
			 6				& /* Fase 2: Generación de $\Sigma_{sr}$ por simplificación de $\Sigma_r$*/ \\
			 7				& $\Sigma_{sr} = \Sigma_r$\\
			 8				& \textbf \REPEAT\\
			 9				& \ESPACIO \FOREACH $A \rightarrow B \in \Sigma_{sr}$ \DO\\
			10				& \ESPACIO \ESPACIO \FOREACH $C \rightarrow D \in \Sigma_{sr}$ \DO\\
			11				& \ESPACIO \ESPACIO \ESPACIO \IF $A \subseteq C$ \THEN\\
			12				& \ESPACIO \ESPACIO \ESPACIO \ESPACIO \IF $C \subseteq A \cup B$ \THEN\\
			13				& \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ESPACIO replace $A \rightarrow B$ and $C \rightarrow D$ by\\
							& \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ESPACIO $A \rightarrow BD$ in $\Sigma_{sr};$\\
			14				& \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ELSE \IF $D \subseteq B$ \THEN\\
			15				& \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ESPACIO  remove $C \rightarrow D$ from 
																					 $\Sigma_{sr}$\\
			16				& \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ELSE replace $C \rightarrow D$ by\\
							& \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ESPACIO \ESPACIO $C-B \rightarrow D-B$ in$\Sigma_{sr};$\\
			17				& \UNTIL $\Sigma_{sr}$ es un punto fijo;\\
			18				& /*Fase 3: Generación de $\Sigma_{dsr}$ por Strong Simplification de $\Sigma_{sr}$*/   \\
			19				& $\Sigma_{dsr}$ = $\Sigma_{sr}$   \\
			20				& \FOREACH $A \rightarrow B \in \Sigma_{dsr}$ and $C \rightarrow D \in \Sigma_{dsr}$ \DO  \\
			21				& \ESPACIO \IF $B \cap C \neq \emptyset \neq D \backslash (A \cup B)$ \THEN   \\
			22				& \ESPACIO \ESPACIO add $AC - B \rightarrow D-(AB)$ to $\Sigma_{dsr}$   \\
			23				& /*Fase 4: Generación de $\Sigma_{do}$ por optimización de $\Sigma_{dsr}$*/   \\
			24				& $\Sigma_{do} = \emptyset$  \\
			25				& \FOREACH $A \rightarrow B \in \Sigma_{dsr}$ \DO  \\
			26				& \ESPACIO \FOREACH $C \rightarrow D \in \Sigma_{dsr}$ DO  \\
			27				& \ESPACIO \ESPACIO \IF $C = A$ \THEN $B = B \cup D$;  \\
			28				& \ESPACIO \ESPACIO \IF $C \nsubseteq A$ \THEN $B = B \backslash D$;   \\
			29				& \ESPACIO \IF $B \neq \emptyset$ \THEN add $A \rightarrow B$ to $\Sigma_{do}$;  \\
			30				& \RETURN $\Sigma_{do}$\\
		\end{tabular}
		
		\section{Implementaciones}
		
		En esta sección se describe la implementación de los algoritmos anteriores en Java y un ejemplo de uso. Ambos algoritmos implementan la interfaz
		\textit{es.uma.pfc.is.algorithms.Algorithm} para que puedan ser ejecutadas por IS Bench. En la siguiente figura, se muestra el diagrama que muestra la jerarquía de
		clases implementada.
				
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{diagramas/clases_api_alg.png}
			\caption{Implementación de Algoritmos}
			\label{fig:clases_api_alg}
		\end{figure}

		Los algoritmos tienen un parámetro de entrada de tipo \textit{ImplicationalSystem}, que es el sistema implicacional inicial y devuelve un valor del mismo tipo 	
		con el sistema implicacional final.
		Ambos hacen uso de la clase \textit{es.uma.pfc.is.algorithms.optbasis.SimplificationLogic} donde se implementan las reglas de equivalencia de la Lógica de
		Simplificación (Simplification Logic) mencionada en el artículo \cite{bib:ref1}.
		
		\subsubsection{CLA}
			\textbf{Clase:} es.uma.pfc.is.algorithms.optbasis.ClaAlgorithm
			
			\begin{verbnobox}[\small]
					public class ClaAlgorithm extends GenericAlgorithm {
    					@Override
					    public ImplicationalSystem execute(ImplicationalSystem input) {
					        ImplicationalSystem directOptimalBasis = new ImplicationalSystem(input);
					        
					        directOptimalBasis = SimplificationLogic.reduce(
					            					directOptimalBasis, getLogger());
					            						
					        directOptimalBasis = SimplificationLogic.strongSimplification(
					            					directOptimalBasis, getLogger());
					            						
					        directOptimalBasis = SimplificationLogic.composition(
					            					directOptimalBasis, getLogger());
					            						
					        directOptimalBasis = SimplificationLogic.optimize(
					            					directOptimalBasis, getLogger());
					      	        
					        return directOptimalBasis;
					    }
					
					    @Override
					    public String getShortName() {
					        return "cla";
					    }
					
					    @Override
					    public String getName() {
					        return "CLA";
					    }
					}
				\end{verbnobox}
								
				
		\subsubsection{Direct Optimal Basis}
			\textbf{Clase:} es.uma.pfc.is.algorithms.optbasis.DirectOptimalBasis
			
			\begin{verbnobox}[\small]
				public class DirectOptimalBasis extends GenericAlgorithm {			
				    
				    /**
				     * Executes the Direct Optimal Basis algorithm.
				     * @param system Input system.
				     * @return Direct optimal basis.
				     */
				    @Override
				    public ImplicationalSystem execute(ImplicationalSystem system) {
				        ImplicationalSystem directOptimalBasis = new ImplicationalSystem(system);
				        
				        // Stage 1 : Generation of sigma-r by reduction of sigma
				        directOptimalBasis = SimplificationLogic.reduce(
				            					directOptimalBasis, getLogger());
				
				        // Stage 2: Generation of sigma-sr by simplification 
				        // (left+right) + composition of sigma-r
				        directOptimalBasis = simplify(directOptimalBasis);
				
				        // Stage 3: Generation of sigma-dsr by completion of sigma-sr
				        directOptimalBasis = SimplificationLogic.strongSimplification(
				            					directOptimalBasis, getLogger());
				
				        // Stage 4: Composition of sigma-dsr
				        SimplificationLogic.composition(directOptimalBasis, getLogger());
				
				        // Stage 5: Generation of sigma-do by optimization of sigma-dsr
				        directOptimalBasis = SimplificationLogic.optimize(
				            					directOptimalBasis, getLogger());
				            
				        return directOptimalBasis;
				    }
				    
				    @Override
					public String getShortName() {
						return "do";
					}
					
					@Override
					public String getName() {
						return "Direct Optimal Basis";
					}
				  }

			\end{verbnobox}
\end{document}